{"0": {
"doc":  "SOP Key points, and Drafts",
"title": "SOP Key points, and Drafts",
"content": "board1 . | Slides.com transfer | Fix/patch base | Setup t5se | . board2 . | temp | temp | temp | . %% kanban:settings . | 0 . | {&quot;kanban-plugin&quot;:&quot;basic&quot;} . | . %% .",
"url": "/thoughts/SOP"
},"1": {
"doc":  "Points to study",
"title": "Points to study",
"content": ". | Machine Learning . | Lecture 1 . | Hypothesis Testing | Density Estimation | Multi Instance Learning | . | . | .",
"url": "/notes/basics_of_probability"
},"2": {
"doc":  "Basics of Probability",
"title": "Basics of Probability",
"content": "Probability . Measure of a subset under relation pretex . Basic Terms . | Sample Space, Event, Proper Subset, Disjoint, Event Space, | Event space for a countable sample space is $2^k$ where k is the distince outcomes | Parition of Set: Disjoint, Union is that Set | Decomposing a set into disjoint if we have a parition available, | Sample Space is all possible outcomes, while Event Space includes the outcomes which we are interested about | Field (Formal gurrantee of Event Space, Sigma and Borel Sigma field on infinite sets) | Measure Zero Set, it is non zero if the sample space is countable or the event is not an isolated point wrt to sample space. | or in other words for continuous distribution its area under the curve and otherwise its countable | . | Axioms- Additive, Normalized and Non-Negative | Conditional Probability of $P(A|B)$ will not be defined if $P(B) = 0$ as then the sample space of new event wont be valid. | Independent Events: $P(A|B) = P(A)$ | Disjoint is $P(A\\cap B) = \\phi$, while Independence is $P(A\\cap B) = P(A)P(B)$ . | Conceptually Disjoint is Getting a head and Getting a tail, while Independent is Getting 6 on dice and Getting a tail, and dependent is Getting a sum of more than 8 when two dice are rolled. | . | Bayes - $P[A|B]P[B] = P[B|A]P[A]$ . | If $P[A|B]$ is conditional (or likelihood) than $P[B|A]$ is posterior, $P[B]$ is prior. | . | . Random Variables . | Random Variable maps events in probability to real valued data (numbers) | Probability Mass function represents the probability of all the states of that data (histogram) . | Probability density function is the counter part of PMF for continuous variables | PMF = PFD*Delta functions | . | Expectation (or Mean) is the average value of the PMF | Histogram number of bins, can be $\\sqrt{N}, \\log_2 N+1$ | Cumulative Distribution function for any given point X, is the area under the graph for $x \\in [-\\inf, X]$ . | Increasing function, minimum is 0 and maximum is 1 | CDF is always right continuous i.e. f(x) == f(x+h) | because probability of event f(3+h) needs to include f(3) | . | Expectation of a random variable need not to be translated back to the actual events . | If we have a coin with $P(H) = \\frac{3}{4}$ and $P(T) = \\frac{1}{4}$, | We denote these events with random variables X(H) = 0, X(T) = 1 | then E[X] = $0*\\frac{3}{4} + 1\\frac{1}{4} = \\frac{1}{4}$ | $E[g(x)] = \\sum_{x\\in \\Omega} g(x) PMF(x)$; Expectation of any function is scaling the x axis with the function values but the PMF stays the same as it is the frequency with which those events occur | so the expectation denotes the average value on the number line scale defined by random variable not on the events as such; and expectation is equivalent to finding the center of mass. | kth Moment is $E[x^k]$; Variance = $E[(x-\\mu)^2]$ | . | PMF exists for which the mean is less than infinite, and those PMF does not have any valid Mean | Cauchy Random variable - PDF with infinite mean | kth Moment of PDF . | $\\int x^k f_X(x) dx$ | . | Variance = $E(X^2) - {\\mu}^2$ | Median = point when the sum of PDF on the left hand side is same as right hand side. | Mode = point with highest PDF or steepest CDF slope | Mean = Integration of 1-CDF, it can be proven by rearranging | . \\[\\begin{aligned} \\mu &amp;amp;= \\int_0^\\infty 1-F(x) dx\\\\ &amp;amp;= \\int_0^\\infty {1-F(x)} dx\\\\ &amp;amp;= \\int_0^\\infty {1-\\int_0^y f(y) dy} dx\\\\ &amp;amp;= \\int_0^\\infty {\\int_y^\\infty f(y) dy} dx\\\\ &amp;amp;= \\int_0^\\infty \\int_0^y f(y) dx dy\\\\ &amp;amp;= \\int_0^\\infty yf(y) dy\\\\ \\end{aligned}\\] The above derivation is possible because of change in the order of integration i.e. changing the flow in which we cover the area . ##Distributions . | Bernoulli Distribution . | Two events with probability $p\\delta (X-1)*1-p\\delta(X)$ | Variance of p(1-p) and mean of p; has maximum variance if p = 1/2 or unbiased. | . | Binomial Distribution . | Probability: $C^n_r p^n (1-p)^{n-r}$ | Variance is np(1-p) and mean is np; has maximum variance with p = 1/2 and as number of events increases | . | Geometric Distribution . | Probability: $(1-p)^{k-1}p$ | Mean is $\\frac{1}{p}$ | . | Poisson Distribution . | Aims to model the occurance of events, like arrival of telephone, calling an uber | Probability: $p_x(k) = \\frac{\\lambda^k}{k!}e^{-\\lambda}$ for one time interval and $\\lambda$ becomes $t\\lambda$ if we are looking for probability of event in t intervals. | It is directly linked to the value of $\\lambda$ which is also known as poisson rate. | Probaility is directly proportional to the rate of event and to the probability with which that event would take place | Poisson Distribution is government by different properties . | Probability of event should be independent of each other | and because of the same it is not possible to get only one event in a given interval | as if the Probability of occurence in an event wrt to previous event would have to be 0 which would make it dependent. -i | . | . | . Machine Learning . | Semi Supervised Learning . | Multi Instance learning | . | UnSupervised Learning | . Phylogeny . Given a VAFs, the task is to generate ancestoral tree such that it adheres to the principles of perfect phylogeny. Terminology . | M matrix of size $(m, n)$ denotes the presence of $m^{th}$ mutation in $n^{th}$ location of the tumor. | V matrix of size $(m, n)$ represents VAFs of $m^{th}$ sample in $n^{th}$ location of the tumor. | T tree, provides the ancestoral representation of mutations based on phylogeny of M matrix. | Character, represents the language of mutation and in our case T or A denoting whether Tumor has been found at a particular site or not. | . Perfect Phylogeny . A phylogeny tree is perfect if it follows the following principle, . | Mathematically, there should be no conflict between the mutations at any two sites. | . \\[Conflict (i, j) = \\begin{cases} true, &amp;amp; \\text{} M[k, j] \\nleqslant M[k, i], M[k, j] \\ngeqslant M[k, i], \\forall k \\in m. \\\\ &amp;amp;\\text{} M[k, j] = M[k, i], \\exists k \\in m. \\\\ false, &amp;amp; otherwise \\end{cases}\\] $\\quad$ for example, . \\[M = \\begin{bmatrix} 1&amp;amp;0&amp;amp;0&amp;amp;0\\\\ 1&amp;amp;1&amp;amp;1&amp;amp;0\\\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\\\ 0&amp;amp;1&amp;amp;0&amp;amp;0 \\end{bmatrix}\\] $\\quad$ Column 1 and 2 in Matrix, M are in conflict while column 3 and 4 are not. | Intutively, it is because we can say that that column 3 is ancestoral clone of column 2 but we cant say the same for column 1 and 2. While with column 3 and 4, we can say these are not ancestoral clones. | Perfect Phylogeny, also ensures the invention of new character[1] is a rare events and does not happen in multiple sites across the phylogeny tree. | . Generation of Evolutionary tree from Perfect Phylogeny . Given M, which has no conflict present in the columns, finding ancestors required as to . | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 . | Input : M function(map) function(M): sort(M) over columns. append($C_0$, M), where $C_0 \\in \\{0\\}.$ for $C, C&#39;$ in columns, where $C&#39; \\ne C$: if $C&#39; \\subseteq C$ then draw an edge in T from $C \\to C&#39;$; for each_node in T: get(characters required) check : any row uses these characters if yes: label node as that row. | . Example: . \\[M = \\begin{bmatrix} 0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;1\\\\ 0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;0\\\\ 0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;1&amp;amp;0\\\\ 0&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0\\\\ 0&amp;amp;0&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0\\\\ 0&amp;amp;1&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0\\\\ 1&amp;amp;1&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0 \\end{bmatrix}, M_{sorted} = \\begin{bmatrix} 1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;1\\\\ 1&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0\\\\ 1&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;0\\\\ 1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;0&amp;amp;0\\\\ 1&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0\\\\ 1&amp;amp;1&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0\\\\ 1&amp;amp;1&amp;amp;1&amp;amp;0&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0 \\end{bmatrix}\\] | | | . | Tree with nodes representing columns | Tree with nodes representing mutation, and Yellow color nodes representing derived mutation | . Importance of VAFs in phylogeny . | | | . | Tree with nodes representing columns | Tree with nodes representing mutation, and Yellow color nodes representing derived mutation | . When we added VAFs information to the mutations, we were able to infer inner relationship between the nodes which got lost with binary representation of M matrix. Maximum Parsimony . | In real world experiments, we are not gurranteed to get perfect phylogeny from the sequencing, and that’s where the principle of maximum parsimony plays its role. | Our aim is to generate parsimonious tree from the input data, i.e. a tree which can represent the M matrix in the best possible representation. | Algorithm (It uses distance based clustering for generation of tree, and Fitcher’s small parsimony principle for labeling of derived clones) | 0 1 2 3 . | Create a separate cluster for each node. Iteratively(till we have only one cluster left): Given all of the clusters, merge two clusters which has the minimum distance. | . where . \\[distance(a, b) = \\frac{distance(a) + distance(b)}{2},\\] and initial distance between two clones are calculated as the edit distance between two clones. | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 . | Given : Tree At first, In bottom up fashion, for each location(k) of node i,$$ Cn_i^k = \\begin{cases} \\cup(Cn_j^k) &amp;amp; if \\cap(Cn_j^k) = \\phi, where\\ n_j = child(n_i)\\\\ \\cap(Cn_j^k) &amp;amp; otherwise\\\\ \\end{cases} $$ In the top down fashion, for each location(k) of node i,$$ Cn_i^k = \\begin{cases} Cn_i^k = Cn_j^k &amp;amp; if Cn_j^k \\in Cn_i^k, where\\ n_j^k = parent(n_i^k)\\\\ Cn_i^k = random(Cn_i^k, 1) &amp;amp; otherwise \\end{cases} $$ . | . | . MixPhy . | With Fletcher’s Algorithm and Agglomerative clustering, we aimed to find the best parsimonious tree from the M but it does not takes into the account key factors that clones in M might have been mixed. | That’s where the problem of Maximum parsimony comes into account. The problem states that we have to find the best steiner tree from the input M. | MixPhy solved this Np-hard problem heuristically by restructing the input as a perfect graph and coloring rows which will get split into multiple clones. | Algorithm . | For the given M, create a graph, G in which two columns are connected if either one is contained in another. where, contained is defined as if all of the element are either $\\leq$ or $\\geq$. | As the containment is a transitive in nature, | i.e. if {0, 0, 1} is contained in {0, 1, 1} and {0, 1, 1} is contained in {1, 1, 1} then {0, 0, 1} is also contained in {1, 1, 1} | Thus the output graphs becomes perfect in nature, and the problem of finding cliques becomes polynomially complex. | If we observe the complement of G is the conflict graph in which any two columns are connected if both are conflicting in nature. | Thus coloring a clique of graph G, with the same color will lead to no two adjacent columns having the same color in the conflict graph. | and for each row in M: if color of all of the mutated column is same, then we do not need to split it otherwise it will get splitted into k different rows where k are the number of unique colors required to color that row. | . | .",
"url": "/notes/basics_of_probability"
},"3": {
"doc":  "Phylogeny of tumor Cells",
"title": "Phylogeny of tumor Cells",
"content": "Phylogeny is the study of organisms, but it has gained quite an attraction in cancer study because of tumor cells being heterogeneous, which implies that the morphological behavior of two cells differs, but their genetic structure changes.",
"url": "/project/CSE690"
},"4": {
"doc":  "Deep Learning",
"title": "Deep Learning",
"content": "In this work, we investigate the problem of colorization of grayscale images. This problem is ill-defined and underconstrained which is why earlier works in this domain have relied on heavy user interaction. We first explored Deep Colorization, which uses multi- scale features and deep neural networks for colorization.",
"url": "/project/CSE641"
},"5": {
"doc":  "Introduction to Quantum Computing",
"title": "Introduction to Quantum Computing",
"content": "The problem of decomposing a N ×N unitary into a quantum circuit was inspired from Task- 4 of IBM Quantum Challenge, 2020. In that challenge, we were asked to design a quantum circuit for a predefined unitary matrix, such that it requires a minimum number of gates. One of the approaches with which this problem can be tackled is to use a machine learning algorithm, in which parameters of U3 gates are learned using gradient descent algorithm with the norm between U and circuit used as the cost function. In this project, at first analytical methods to compute the gradients were used, which worked well for classification related tasks but could not hold up to unitary estimation. After that, numerical gradient estimation techniques were used to solve the problem.",
"url": "/project/CSE622"
},"6": {
"doc":  "Natural Language Processing",
"title": "Natural Language Processing",
"content": "Concept of context Understanding in Natural Language Processing (NLP) has led to paradigm shift from word embedding based models to inculcation of semantics and context based features.It has great applications when it comes to machine language generation,dialog mod- eling ,etc for improving the quality and relevance.",
"url": "/project/CSE556"
},"7": {
"doc":  "Advance Computer Vision",
"title": "Advance Computer Vision",
"content": "This project extends the barebone conditional autoregressive network towards faster training, evalua- tion, and learning to color from thermal input instead of grayscale.",
"url": "/project/CSE544"
},"8": {
"doc":  "Colorization - Sampling Color from GrayScale and I.R. Images",
"title": "Colorization - Sampling Color from GrayScale and I.R. Images",
"content": "Given a grayscale image, it is a daunting task, even for a human, to visualize it in color. See Figure 1 for examples. However, a human may try to find semantic clues like texture and world knowledge to assign colors to objects. For example, the grass is mostly green, or the sky is mostly blue. But these clues may also fail sometimes, as shown in Figure 1(middle). Thus, in this work, the focus was on assigning a plausible set of colors to the Image, which may or may not be the same as the ground truth. Fig:1 GrayScale Images and Corresponding Color . The primary motivation behind pursuing this problem was that many images do not have color information. Also, the problem of Colorization is self-supervised and does not require a pair-wise dataset. The aim is to solve it in generative fashion, such that if we feed the same grayscale Image to the network k times, it may generate different output each time. A generative network’s benefit is that it may color the cloth’s stripes (Figure 2), gray or red. Fig:2 Plants in the left Image are entirely green, not in the right . The solution is based on PixColor, which is state of the art autoregressive generative neural networks for Colorization, i.e., the output of $i^{th}$ pixel is not just conditioned on the latent representation of the grayscale Image, X but also on the previous outputs, $[i-t, i-t+1, i-t+2\\ …\\ i-1]$ where t denotes the receptive field. Given $X \\in [H, W]$, we first extracts the features $Y_1$ using Resnet-101 of size $[\\frac{H}{4}, \\frac{W}{4}, 1024]$. These features are then passed into an adaption network and use three convolution layers to adapt the features required by pixelcnn. The output from the adaption network is of size $[\\frac{H}{4}, \\frac{W}{4}, 64]$, and is fed into conditional pixelcnn. It masks the weights of a convolutional layer to prohibit pixel $x_i$ from using any information about the future samples $(x_{i+1:N})$. Training is the same as that of any other end-to-end trainable architecture (as ground truth data was used under teacher training mechanism), but during testing, for each pixel $i$, the class is sampled from a multinomial distribution defined by the softmax output of the network. Fig:3 Result of Colorization Algorithm . The first seven images in carousal(at the top) are the PixColor algorithm results with key insights from each of the Images. Extension towards I.R. images . I decided to continue working on image colorization during my next semester, focusing on ​reducing the artifacts and ​improving larger objects’ coloring​. The output from pixelcnn is given to a fully convolutional network, acting as a denoiser, inspired by Tacotron, a source synthesis architecture. Fig:4 Correction of Green Artifact as shown in left Image . After that, my professor suggested applying image colorization on I.R. images. In applications under low lighting, I.R. cameras come in handy, but interpreting I.R. images is not straightforward for a human, and hence translating to RGB improves its understandability. I.R. images introduced two challenges, i) it is no longer a self-supervised task and requires a parallel dataset, ii) it is computationally expensive since with grayscale images, we can learn the color information at less spatial resolution(Figure 5-middle) and upscale it, with minimal impact on visual quality but with I.R. images, we need to learn Luminicance too(Figure 5-bottom). | Input Image | | . | Color channels downscaled and Interploated | | . | All channels are downscaled and interpolated | | . Figure 5: Effect of downsampling on image quality . For I.R. to RGB, I did not directly use PixelColor to generate color images but first used ImageGAN with wassterin loss. It ended up being blurry because we were averaging the loss over all of the pixels (Table - 1). | Input - IR | Target - RGB | Output - RGB | . | | | | . | | | . Table:1 Blurry Output when GAN’s are not used . An I.R. image is first passed through GAN, which generates grayscale output followed by PixColor for sampling RGB from the generated grayscale. | Input I.R. | Target GrayScale | Generated GrayScale | . | | | | . | | | . | | | . | | | . | | | . | | | . Table 2: Output of ImageGAN . The ImageGAN model produced close to ground truth for many situations (Table 2 first four rows). Still, the model’s performance deteriorated when uncommon objects were present in the I.R. image, like a person on the cycle or person themselves, highlighting the importance of richer data sources. The last five images in carousal(at the top) are the results of the I.R. to color algorithm with key insights from each of the Images. Datasets . The ADE20K scene parsing dataset was used for PixColor training; it has 20K training and 1.5k validation samples. Also, there was a pretrained resnet101 network, which helped speed up the training process. For I.R. to RGB translation, the kaist multispectral benchmark was used. It is divided into multiple files, with each file consisting of over 10000 images, but it lacks the spatial resolution. I tested six different datasets that have pair-wise I.R. and RGB images and found it to be most aligned. Training and Analysis . PixColor was trained for 50 epochs, in 100% teacher-training mechanism, i.e. during training pixelcnn autoregressive considers ground truth samples as previous t inputs. The ImageGAN was trained for 150 epochs, I stopped after 150 epochs due to computation constraints. Evaluating generative models is very hard, that’s why I tested the color distribution generated by the PixColor and observed biases towards the brown color which was present in the ADE20k data itself. Currently, I am studying more about GANs to train them effectively with fewer data points, if you have any questions or suggestion, please let me know on Twitter or instagram. References . | Guadarrama, Sergio, et al. “Pixcolor: Pixel recursive colorization.” arXiv preprint arXiv:1705.07208 (2017). | Salimans, Tim, et al. “Pixelcnn++: Improving the pixelcnn with discretized logistic mixture likelihood and other modifications.” arXiv preprint arXiv:1701.05517 (2017). | Oord, Aaron van den, et al. “Conditional image generation with pixelcnn decoders.” arXiv preprint arXiv:1606.05328 (2016). | Zhou, Bolei, et al. “Scene parsing through ade20k dataset.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2017. | Hwang, Soonmin, et al. “Multispectral pedestrian detection: Benchmark dataset and baseline.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2015. | Wang, Yuxuan, et al. “Tacotron: Towards end-to-end speech synthesis.” arXiv preprint arXiv:1703.10135 (2017). | Arjovsky, Martin, Soumith Chintala, and Léon Bottou. “Wasserstein generative adversarial networks.” International conference on machine learning. PMLR, 2017. | Isola, Phillip, et al. “Image-to-image translation with conditional adversarial networks.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2017. | .",
"url": "/notes/study-of-colorization"
},"9": {
"doc":  "How does tree metrics works",
"title": "How does tree metrics works",
"content": "Comparing MLTED, RF distance, and TreeVec . MLTED . | | | . | Tree 1 | Tree 2 | . | | . | Tree 3 | Tree 4 | . | | . | Tree 5 | Tree 6 | . On comparision of tree 1 with tree3 and 4, the output from MLTED was 100% similarity and 0 edit distance with the normalized output as 1. Even though Tree(1) as only three nodes while others have many more. It is because Tree(1) is lacking information which other trees have but there is no error in the output which needs to be corrected. When the comparison is made between Tree(2) and Tree(1, 3, 4), edit distance of 14 was found in each case and similarity of 3 because only three nodes are common (a, b, c) in any pair and Tree(2) on the one hand is projecting taxa(b, c, d) as independent (parallel) while in other trees these three mutations happens simultaneously. Tree(5) deals with the condition when one tree shows different order of mutation than the other, while Tree(6) addons to Tree(5) by replacing the root with some other elements. | Tree(5) . | With Tree(1) 100% similarity(of 10), as already described. | Tree(2) Similarity of 3, as already described. | Tree(3) Similarity of 9, and edit distance of 2. It is because 9 nodes are in correct position out of 10 (h is not in). 1 distance is required to remove h, and other to add it as child of g. | Tree(4) Similarity of 4, as we have shuffled nodes. | . | Tree(6) . | With Tree(1) . Similarity of 8 and distance of 4, . | 1 to remove a from b node. | 1 to remove g from the b node. | 1 to add b as child of a. | 1 to add g as child of a. | . | . | . The final score can be calculated in two ways, $\\frac{similarity}{num_nodes}$, or $\\frac{edit_distance}{2*num_nodes}$. RF metric, . It is implied by sum of two terms, A+B where A represents number of partition of data implied by $T_1$ but not $T_2$, while B represents versa. RF metric ensures that we have exact ordering of taxas in tree whereas MLTED only ensured that nodes(can contain multiple taxas) are in correct order. It is not possible to compare the trees present in the above tables, as RF metric requires same set of leaf nodes in the tree. Therefore, table given below will help in better understanding of RF metric. | | | . | Tree 1 | Tree 2 | . | | . | Tree 3 | Edges Labelled | . In RF distance, we are required to calculate the sum of splits which are present in tree 1 but not tree 2 and vice versa. Therefore using the edge labelling (in red color). We define split of each tree (q split is not required as it would be same as that of x) as . | Tree 1 | Tree 2 | Tree 3 | . | C(x)ABD | C(x)ABD | B(x)ACD | . | D(y)ABC | B(y)ADC | C(y)ABD | . | B(z)ACD | D(z)ACB | D(z)ACB | . | A(r)BCD | A(r)BCD | A(r)BCD | . | BD(p)AC | BD(p)AC | CD(p)AB | . The splits between Tree(1) and Tree(2) as it does not matter which branch splits it because of being unrooted. While there are two unique splits in case of Tree(3) and Tree(1) or Tree(2). Thus, RF distance would be 2 in this case. If needed normalization then it is done by dividing it with total number of splits presents in both of the tree. Therotically, we are not bounded by comparing tree which does not have same number of leaves but tools does not allow. TreeVec . It is also a metric for unrooted tree, and is primarly to pool different taxas based on their context. Basically, if the tree has leaf nodes as ${a_1, a_2, b_1, b_2}$. It implies $a_1, a_2$ belongs to category a while $b_1, b_2$ belongs to category b. No other method can help in this case. So, this method is very trivial. | 0 1 2 . | Calculates minimum depth from root(can be assigned to any node) to pair of leaf nodes. Take mean of all depths for all categories. Compute Eucledian distance between all of the categories for all of the trees. | . | | | . | Tree(1) | Tree(2) | . In this example, there are no examples in the subcategories.Minimum depth for each pair of the nodes is presented in the table below. | Pair | Tree(1) | Tree(2) | . | $a \\to b$ | 0 | 1 | . | $a \\to c$ | 0 | 2 | . | $a \\to d$ | 0 | 2 | . | $a \\to e$ | 0 | 0 | . | $b \\to c$ | 1 | 1 | . | $b \\to d$ | 1 | 1 | . | $b \\to e$ | 1 | 0 | . | $c \\to d$ | 2 | 3 | . | $c \\to e$ | 2 | 0 | . | $d \\to e$ | 3 | 0 | . Thus, final distance is calculated between these two vectors (eucleadian in this example), 4.89.",
"url": "/notes/tree_metrics_in_detail"
},"10": {
"doc":  "Basics of Phylogeny",
"title": "Basics of Phylogeny",
"content": "Phylogeny . Given a VAFs, the task is to generate ancestoral tree such that it adheres to the principles of perfect phylogeny. Terminology . | M matrix of size $(m, n)$ denotes the presence of $m^{th}$ mutation in $n^{th}$ location of the tumor. | V matrix of size $(m, n)$ represents VAFs of $m^{th}$ sample in $n^{th}$ location of the tumor. | T tree, provides the ancestoral representation of mutations based on phylogeny of M matrix. | Character, represents the language of mutation and in our case T or A denoting whether Tumor has been found at a particular site or not. | . Perfect Phylogeny . A phylogeny tree is perfect if it follows the following principle, . | Mathematically, there should be no conflict between the mutations at any two sites. | . \\[Conflict (i, j) = \\begin{cases} true, &amp;amp; \\text{} M[k, j] \\nleqslant M[k, i], M[k, j] \\ngeqslant M[k, i], \\forall k \\in m. \\\\ &amp;amp;\\text{} M[k, j] = M[k, i], \\exists k \\in m. \\\\ false, &amp;amp; otherwise \\end{cases}\\] $\\quad$ for example, . \\[M = \\begin{bmatrix} 1&amp;amp;0&amp;amp;0&amp;amp;0\\\\ 1&amp;amp;1&amp;amp;1&amp;amp;0\\\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\\\ 0&amp;amp;1&amp;amp;0&amp;amp;0 \\end{bmatrix}\\] $\\quad$ Column 1 and 2 in Matrix, M are in conflict while column 3 and 4 are not. | Intutively, it is because we can say that that column 3 is ancestoral clone of column 2 but we cant say the same for column 1 and 2. While with column 3 and 4, we can say these are not ancestoral clones. | Perfect Phylogeny, also ensures the invention of new character[1] is a rare events and does not happen in multiple sites across the phylogeny tree. | . Generation of Evolutionary tree from Perfect Phylogeny . Given M, which has no conflict present in the columns, finding ancestors required as to . | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 . | Input : M function(map) function(M): sort(M) over columns. append($C_0$, M), where $C_0 \\in \\{0\\}.$ for $C, C&#39;$ in columns, where $C&#39; \\ne C$: if $C&#39; \\subseteq C$ then draw an edge in T from $C \\to C&#39;$; for each_node in T: get(characters required) check : any row uses these characters if yes: label node as that row. | . Example: . \\[M = \\begin{bmatrix} 0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;1\\\\ 0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;0\\\\ 0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;1&amp;amp;0\\\\ 0&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0\\\\ 0&amp;amp;0&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0\\\\ 0&amp;amp;1&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0\\\\ 1&amp;amp;1&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0 \\end{bmatrix}, M_{sorted} = \\begin{bmatrix} 1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;1\\\\ 1&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0\\\\ 1&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;0\\\\ 1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;0&amp;amp;0\\\\ 1&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0\\\\ 1&amp;amp;1&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0\\\\ 1&amp;amp;1&amp;amp;1&amp;amp;0&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0 \\end{bmatrix}\\] | | | . | Tree with nodes representing columns | Tree with nodes representing mutation, and Yellow color nodes representing derived mutation | . Importance of VAFs in phylogeny . | | | . | Tree with nodes representing columns | Tree with nodes representing mutation, and Yellow color nodes representing derived mutation | . When we added VAFs information to the mutations, we were able to infer inner relationship between the nodes which got lost with binary representation of M matrix. Maximum Parsimony . | In real world experiments, we are not gurranteed to get perfect phylogeny from the sequencing, and that’s where the principle of maximum parsimony plays its role. | Our aim is to generate parsimonious tree from the input data, i.e. a tree which can represent the M matrix in the best possible representation. | Algorithm (It uses distance based clustering for generation of tree, and Fitcher’s small parsimony principle for labeling of derived clones) | 0 1 2 3 . | Create a separate cluster for each node. Iteratively(till we have only one cluster left): Given all of the clusters, merge two clusters which has the minimum distance. | . where . \\[distance(a, b) = \\frac{distance(a) + distance(b)}{2},\\] and initial distance between two clones are calculated as the edit distance between two clones. | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 . | Given : Tree At first, In bottom up fashion, for each location(k) of node i,$$ Cn_i^k = \\begin{cases} \\cup(Cn_j^k) &amp;amp; if \\cap(Cn_j^k) = \\phi, where\\ n_j = child(n_i)\\\\ \\cap(Cn_j^k) &amp;amp; otherwise\\\\ \\end{cases} $$ In the top down fashion, for each location(k) of node i,$$ Cn_i^k = \\begin{cases} Cn_i^k = Cn_j^k &amp;amp; if Cn_j^k \\in Cn_i^k, where\\ n_j^k = parent(n_i^k)\\\\ Cn_i^k = random(Cn_i^k, 1) &amp;amp; otherwise \\end{cases} $$ . | . | . MixPhy . | With Fletcher’s Algorithm and Agglomerative clustering, we aimed to find the best parsimonious tree from the M but it does not takes into the account key factors that clones in M might have been mixed. | That’s where the problem of Maximum parsimony comes into account. The problem states that we have to find the best steiner tree from the input M. | MixPhy solved this Np-hard problem heuristically by restructing the input as a perfect graph and coloring rows which will get split into multiple clones. | Algorithm . | For the given M, create a graph, G in which two columns are connected if either one is contained in another. where, contained is defined as if all of the element are either $\\leq$ or $\\geq$. | As the containment is a transitive in nature, | i.e. if {0, 0, 1} is contained in {0, 1, 1} and {0, 1, 1} is contained in {1, 1, 1} then {0, 0, 1} is also contained in {1, 1, 1} | Thus the output graphs becomes perfect in nature, and the problem of finding cliques becomes polynomially complex. | If we observe the complement of G is the conflict graph in which any two columns are connected if both are conflicting in nature. | Thus coloring a clique of graph G, with the same color will lead to no two adjacent columns having the same color in the conflict graph. | and for each row in M: if color of all of the mutated column is same, then we do not need to split it otherwise it will get splitted into k different rows where k are the number of unique colors required to color that row. | . | .",
"url": "/notes/basics_of_clonal_evolution"
},"11": {
"doc":  "Introduction to Explainable AI",
"title": "Introduction to Explainable AI",
"content": "Paper - 1, Measuring the Quality of Explanations: The System Causability Scale . | With the current advancements in Machine Learning, and AI. It is not possible to develop autonomous systems which can learn. | But this also leads to opaques in terms of their performance, and under what circumstances or conditions leads to change in their observation and performance. | It becomes certainly important in critical systems like Medical Imaging, or self driving car, or automatic flight systems. | It does not foster trust, acceptance and the most important responsibility. | . | Explainable AI aims to | .",
"url": "/notes/xAI/intro"
},"12": {
"doc":  "SOP Key points, and Drafts",
"title": "SOP Key points, and Drafts",
"content": "Final Version . The study of intelligence focuses on three fundamental approaches — social science, biological, and technological, with the end goal being creating intelligence. My decision to pursue research in artificial intelligence is inspired by the following question: Is there anything we cannot do if we successfully combine human intellect with a computer’s efficacy? . I have gained a breadth of knowledge in A.I. from working on ETA prediction of buses running in Delhi, Infrared to RGB image translation, prediction root-cause mutation behind a tumor. Even though each problem has different inputs, parameters, and outputs, the same class of algorithms achieve the state of the art results. Thus, creating artificial intelligence is not limited to technologizing intelligence models seen in humans but involves venturing into uncharted territories, opening up infinite possibilities. I wish to delve into A.I. at a much deeper level focusing on natural language understanding, computer vision, reinforcement learning, and being closely involved in advancing these areas. Hence, I want to focus on a career in research, where I know I will be continuously challenged and will have the chance to work on revolutionary technologies that help shape A.I.’s future. In my junior year of undergraduate studies, I worked on my first project in Artificial Intelligence. The goal was to detect emotion from speech using a Deep Neural Network and Extreme Learning Machine. I used the experience gained in this project to work on the Cocktail party problem, which aims to extract the desired speech from a mixture of sounds. We developed an algorithm based on Speech Synthesis architecture, which models the source speaker’s mel spectrogram directly rather than learning the mask on the input mixture. In my freshman year of graduate studies, I worked on the Image Colorization problem, intending to model the color distribution conditioned on grayscale input. Initially, we solved it in a discriminative manner, i.e., if we give the same image n times, the output remains the same. But as we know, Image Colorization is an ill-defined problem; for a given grayscale input, there can be more than one possible color image. To achieve that, we expanded it to work in a generative fashion using an autoregressive algorithm. I decided to continue working on image colorization during my next semester, focusing on reducing the artifacts and improving the coloring of larger objects. To achieve this, we fed the output to a fully convolutional network, acting as a denoiser, inspired by Tacotron, a source synthesis architecture. After that, my professor suggested applying image colorization on I.R. images. In applications under low lighting, I.R. cameras come in handy, but interpreting I.R. images is not straightforward for a human, and hence translating to RGB improves its understandability. I.R. images introduced two challenges, i) it is no longer a self-supervised task and requires a parallel dataset, ii) it is computationally expensive since with grayscale images, we can learn the color information at less spatial resolution and upscale it, with minimal impact on visual quality but with I.R. images, we need to learn Luminicance too. I first tried the discriminative model, but the output was blurry even after extensive hyperparameter tuning. I observed that this is happening because of pair-wise loss, as the RGB images are more detailed than their I.R. counterparts, which introduces blurriness around different objects. To reduce the blurring, I trained a GAN based model, as it is not optimized using pair-wise loss. I am quite excited to work in the domain of Contextual Matching or Project Melange because 1) I have explored both of the topics on my own, and 2) I had few ideas which I wanted to implement in both, but I could not because of time limitations. Eg. In contextual matching, I worked on a project where we first model explicit context between two sentences, followed by generating a sentence conditioned on an explicit context and an input sentence. I wanted to extend the generation process where the context is implicit, just like answering questions based on an unseen passage. | https://www.careereducation.columbia.edu/resources/resumes-impact-creating-strong-bullet-points | https://www.inc.com/bill-murphy-jr/google-recruiters-say-these-5-resume-tips-including-x-y-z-formula-will-improve-your-odds-of-getting-hired-at-google.html . | . Key points . | Class 9th . | 9.0 pointer, science project | . | Class 10th . | 10.0 pointer, merit | . | Class 11th . | Downfall | . | Class 12th . | 95 in PCM, apart nothing | . | Bachelors into CS without much of knowledge except basics of HTML . | first yr . | build an image compression algorithm in Matlab, | developed a string search algorithm based on tries, serialization, and hashing | 3d modeling of space capsule demonstrating the importance of dome at the bottom. | . | second semester . | … | . | . | Comprehensive Projects . | IBM Quantum Challenge, participation in | Grayscale and Infrared Image Colorization | Object Detection | Speech Generation, and Source separation | ETA prediction | Phylogeny estimation | Conditional Generation of sentences | . | Undergraduation . | My Majors include mathematics, computer science and electronics and :q | have worked majorly in optimization of algorithms and developing new tools to aid other users in one way or another. | Then during my second year internship, I worked with DRDO over machine consciousness and here is where I was introduced with Human Computer interaction somewhat. My major work lied in the understanding what machine consciousness is, it was majorily theortical based. | I also in the mean time worked in scraping and building automatic testing tools by using phantomJS. | During my 3rd year internship, I went to National Aeronautics Laborities Bengaluru, there I was selected as APJ Abdul Kalam Scholar to work with CSIR under project invoving keytrokes dynamics and its currently at brink of completion (I was able to complete it using RNNs and was working on research paper but then I found out about the CNNS and how much efficient they are, then I asked my professor about it and he was fine, so I am completing CNN implementation of it) | It was to develop an algorithm which reduce access time of large corpus using tries and hashing, at the end we also implemented serialization to store bytestream directly and that’s why my major interest shifted to Java. After that for another 6 months, I completely focused on developing algorithms and applications over Java. | It was complemented by internship at DRDO, which helped me learning the concepts of neural networks, consciousness and whether consciousness can be derived in machines or not. This was majorly a theoretical internship with prototyping over a tank bot, but it helped me in laying my foundations of machine learning. | During my next summer I won a scholarship under APJ Abdul Kalam Fellowship and was given opportunity to work at National Aeronautics laboratories in CSIR-4Pi under Senior Principal Scientist Dr. GK Patra. I worked on a project involving time series analysis of keystrokes dynamics and natural language analysis of keystrokes to increase the accuracy of prediction. | . | .",
"url": "/thoughts/SOP"
}
}